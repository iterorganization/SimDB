import sys
import argparse
from typing import (Any, List, Dict, Tuple, TYPE_CHECKING, TypeVar)

if TYPE_CHECKING or 'sphinx' in sys.modules:
    # Only importing these for type checking and documentation generation in order to speed up runtime startup.
    from simdb.database.models import Simulation, ValidationParameters, Summary
    from simdb.config import Config
else:
    Config = TypeVar('Config')


def _required_argument(args: Any, command: str, argument: str):
    if not getattr(args, argument):
        raise argparse.ArgumentError(None, "{} argument must be provided with {} command".format(argument, command))


def _flatten_dict(values: Dict) -> List[Tuple[str, str]]:
    items = []
    for (k, v) in values.items():
        if type(v) == list:
            for n, i in enumerate(v):
                items.append(("{}[{}]".format(k, n), i))
        elif type(v) == dict:
            for i in _flatten_dict(v):
                items.append(("{}.{}".format(k, i[0]), i[1]))
        else:
            items.append((k, v))
    return items


def _list_simulations(simulations: List["Simulation"], verbose: bool=False, metadata_names: str=None) -> None:
    if len(simulations) == 0:
        print("No simulations found")
        return

    lines = []
    header = ["UUID", "alias"]
    if verbose:
        header.append("datetime")
        header.append("status")

    for sim in simulations:
        line = [str(sim.uuid), sim.alias]
        if verbose:
            line.append(sim.datetime)
            line.append(sim.status)
        if metadata_names:
            for name in metadata_names.split(","):
                if sim.find_meta(name):
                    if name not in header:
                        header.append(name)
                    line.append(sim.find_meta(name)[0].data()["value"])
        if not lines:
            lines.append(header)
        lines.append(line)

    column_widths = [0] * len(header)
    for line in lines:
        width = 0
        for col in range(len(line)):
            width = len(str(line[col]))
            if width > column_widths[col]:
                column_widths[col] = width
              
    line_written = False
    for line in lines:
        for col in range(len(line)):
            print("%s" % str(line[col]).ljust(column_widths[col] + 1), end="")
        print()
        if not line_written:
            print("-" * (sum(column_widths) + len(column_widths) - 1))
            line_written = True
        

def _list_validation_parameters(parameters: List["ValidationParameters"]) -> None:
    if len(parameters) == 0:
        print("No validation parameters found")
        return

    max_device = max(len(str(param.device)) for param in parameters)
    max_device = max(max_device, 6)
    device_spaces = (6 - max_device)
    print("Device%s Scenario" % (" " * device_spaces))
    print("-" * (15 + device_spaces))

    for param in parameters:
        print("%s%s %s" % (param.device, " " * (max_device - len(param.device)), param.scenario))


def _list_summaries(summaries: List["Summary"]) -> None:
    if len(summaries) == 0:
        print("No summaries found")
        return

    for summary in summaries:
        print("{} = {}".format(summary.key, summary.value))


class Command:
    """Base class for CLI commands.

    Subclasses should overload the _help variable with the help string to print when the --help option is being run.
    They should also implement the abstract methods add_arguments (optional) and run (mandatory).
    """
    _help: str = NotImplemented

    @property
    def help(self) -> str:
        return self._help

    def add_arguments(self, parser: argparse.ArgumentParser) -> None:
        """Update the ArgumentParser with the arguments for this command.

        :param parser: the ArgumentParser to update
        """
        pass

    def validate_arguments(self, parser: argparse.ArgumentParser, args: Any) -> None:
        """Perform any custom argument validation which can't be handled by the standard ArgumentParser options.

        This might be required for cross argument validation, i.e. an option that is only valid when another option is
        used.
        :param parser: the ArgumentParser to use to report errors
        :param args: the arguments to check
        """
        pass

    def run(self, args: Any, config: Config) -> None:
        """Run the command with the Namespace object that is generated by the ArgumentParser by parsing the command
        line arguments.

        :param args: the object containing details of what arguments where specified on the command line
        :param config: the application config object
        """
        raise NotImplementedError
