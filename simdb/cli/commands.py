import os
import sys
import argparse
from typing import (Any, Optional, List, Dict, Tuple, TYPE_CHECKING, TypeVar)
from enum import (Enum, auto)
from ..docstrings import inherit_docstrings

if TYPE_CHECKING or 'sphinx' in sys.modules:
    # Only importing these for type checking and documentation generation in order to speed up runtime startup.
    from ..database.models import Simulation, ValidationParameters, Summary
    from ..config.config import Config
else:
    Config = TypeVar('Config')


def _required_argument(args: Any, command: str, argument: str):
    if not getattr(args, argument):
        raise argparse.ArgumentError(None, "{} argument must be provided with {} command".format(argument, command))


def _flatten_dict(values: Dict) -> List[Tuple[str, str]]:
    items = []
    for (k, v) in values.items():
        if type(v) == list:
            for n, i in enumerate(v):
                items.append(("{}[{}]".format(k, n), i))
        elif type(v) == dict:
            for i in _flatten_dict(v):
                items.append(("{}.{}".format(k, i[0]), i[1]))
        else:
            items.append((k, v))
    return items


class Command:
    """Base class for CLI commands.

    Subclasses should overload the _help variable with the help string to print when the --help option is being run.
    They should also implement the abstract methods add_arguments (optional) and run (mandatory).
    """
    _help: str = NotImplemented

    @property
    def help(self) -> str:
        return type(self)._help

    def add_arguments(self, parser: argparse.ArgumentParser) -> None:
        """Update the ArgumentParser with the arguments for this command.

        :param parser: the ArgumentParser to update
        """
        pass

    def run(self, args: Any, config: Config) -> None:
        """Run the command with the Namespace object that is generated by the ArgumentParser by parsing the command
        line arguments.

        :param args: the object containing details of what arguments where specified on the command line
        :param config: the application config object
        """
        raise NotImplementedError


@inherit_docstrings
class QueryCommand(Command):
    """Command to perform queries on the Simulation metadata and return the matching simulations.
    """
    _help = "query the simulations"

    class QueryArgs(argparse.Namespace):
        verbose: bool
        constraint: List[str]
        attributes: str

    class QueryType(Enum):
        META = auto()
        PROVENANCE = auto()
        SUMMARY = auto()

    def __init__(self, query_type: QueryType=QueryType.META) -> None:
        """Specify what type of query should be perfomed by this command, based on the enum value provided.

        :param query_type: the query type to perform when the command is run
        """
        self._query_type = query_type

    def add_arguments(self, parser: argparse.ArgumentParser):
        parser.add_argument("-v", "--verbose", action="store_true", help="print more verbose output")
        parser.add_argument("-a", "--attributes", dest="attributes", default=None, help="list of attributes to include in output")
        parser.add_argument('constraint', nargs='*', help="constraint in the form key=value or key=in:value")

    def run(self, args: QueryArgs, _: Config) -> None:
        if not args.constraint:
            raise argparse.ArgumentTypeError("At least one constraint must be provided")

        from ..database.database import get_local_db

        equals = {}
        contains = {}
        for item in args.constraint:
            if '=' not in item:
                raise argparse.ArgumentTypeError("Invalid constraint")
            (key, value) = item.split('=')
            if '=in:' in item:
                contains[key] = value.replace('in:', '')
            else:
                equals[key] = value

        db = get_local_db()
        if self._query_type == QueryCommand.QueryType.META:
            simulations = db.query_meta(equals=equals, contains=contains)
        elif self._query_type == QueryCommand.QueryType.PROVENANCE:
            simulations = db.query_provenance(equals=equals, contains=contains)
        elif self._query_type == QueryCommand.QueryType.SUMMARY:
            simulations = db.query_summary(equals=equals, contains=contains)
        else:
            raise Exception("Unknown query type " + self._query_type.name)
        _list_simulations(simulations, verbose=args.verbose)


@inherit_docstrings
class ProvenanceCommand(Command):
    """Command to work with provenance files -- create, ingest, query & print.
    """
    _help = "provenance tools"

    class CreateCommand(Command):
        _help = "create the provenance file from the current system"

        def add_arguments(self, parser: argparse.ArgumentParser) -> None:
            parser.add_argument("file", help="provenance file")

        def run(self, args: Any, _: Config) -> None:
            from .provenance import create_provenance_file

            create_provenance_file(args.file)

    class IngestCommand(Command):
        _help = "ingest the provenance file"

        def add_arguments(self, parser: argparse.ArgumentParser) -> None:
            parser.add_argument("sim_id", metavar="uuid|alias", help="simulation UUID or alias")
            parser.add_argument("file", help="provenance file")

        def run(self, args: Any, _: Config) -> None:
            from ..database.database import get_local_db
            from .provenance import read_provenance_file

            prov = read_provenance_file(args.file)
            db = get_local_db()
            db.insert_provenance(args.sim_id, prov)

    class PrintCommand(Command):
        _help = "print the provenance for a simulation"

        def add_arguments(self, parser: argparse.ArgumentParser) -> None:
            parser.add_argument("sim_id", metavar="uuid|alias", help="simulation UUID or alias")

        def run(self, args: Any, _: Config) -> None:
            from ..database.database import get_local_db
            _required_argument(args, "ingest", "sim_id")
            db = get_local_db()
            prov = db.get_provenance(args.sim_id)
            print(str(prov))

    _commands = {
        "create": CreateCommand(),
        "ingest": IngestCommand(),
        "print": PrintCommand(),
        "query": QueryCommand(QueryCommand.QueryType.PROVENANCE),
    }

    def add_arguments(self, parser: argparse.ArgumentParser) -> None:
        command_parsers = parser.add_subparsers(title="action", dest="action")
        command_parsers.required = True

        for name, command in self._commands.items():
            sub_parser = command_parsers.add_parser(name, help=command.help)
            command.add_arguments(sub_parser)

    class ProvenanceArgs(QueryCommand.QueryArgs):
        action: str
        file: Optional[str]
        sim_id: Optional[str]

    def run(self, args: ProvenanceArgs, config: Config) -> None:
        self._commands[args.action].run(args, config)


@inherit_docstrings
class IngestCommand(Command):
    """Command to ingest simulation manifest files.
    """
    _help = "ingest a manifest file"

    def add_arguments(self, parser: argparse.ArgumentParser) -> None:
        parser.add_argument("manifest_file", help="manifest file location")
        parser.add_argument("--alias", "-a", help="alias of an existing manifest to update, or a new alias use")
        parser.add_argument("--uuid", "-u", help="set the uuid of the simulation")
        parser.add_argument("--update", action="store_true", help="update an existing manifest")

    class IngestArgs(argparse.Namespace):
        manifest_file: str
        alias: Optional[str]
        uuid: Optional[str]
        update: bool

    def run(self, args: IngestArgs, _: Config) -> None:
        from ..database.database import get_local_db
        from ..database.models import Simulation
        from .manifest import Manifest

        manifest = Manifest()
        manifest.load(args.manifest_file)
        manifest.validate()
        # verify_metadata({}, manifest.metadata)

        simulation = Simulation(manifest)
        simulation.alias = args.alias
        if args.uuid:
            simulation.uuid = args.uuid

        db = get_local_db()
        db.insert_simulation(simulation)
        print("success")


def _list_simulations(simulations: List["Simulation"], verbose: bool=False, metadata_names: str=None) -> None:
    if len(simulations) == 0:
        print("No simulations found")
        return

    lines = []
    header = ["UUID", "alias"]
    if verbose:
        header.append("datetime")
        header.append("status")

    for sim in simulations:
        line = [str(sim.uuid), sim.alias]
        if verbose:
            line.append(sim.datetime)
            line.append(sim.status)
        if metadata_names:
            for name in metadata_names.split(","):
                if sim.find_meta(name):
                    if name not in header:
                        header.append(name)
                    line.append(sim.find_meta(name)[0].data()["value"])
        if not lines:
            lines.append(header)
        lines.append(line)

    column_widths = [0] * len(header)
    for line in lines:
        width = 0
        for col in range(len(line)):
            width = len(str(line[col]))
            if width > column_widths[col]:
                column_widths[col] = width
              
    line_written = False
    for line in lines:
        for col in range(len(line)):
            print("%s" % str(line[col]).ljust(column_widths[col] + 1), end="")
        print()
        if not line_written:
            print("-" * (sum(column_widths) + len(column_widths) - 1))
            line_written = True
        

def _list_validation_parameters(parameters: List["ValidationParameters"]) -> None:
    if len(parameters) == 0:
        print("No validation parameters found")
        return

    max_device = max(len(str(param.device)) for param in parameters)
    max_device = max(max_device, 6)
    device_spaces = (6 - max_device)
    print("Device%s Scenario" % (" " * device_spaces))
    print("-" * (15 + device_spaces))

    for param in parameters:
        print("%s%s %s" % (param.device, " " * (max_device - len(param.device)), param.scenario))


def _list_summaries(summaries: List["Summary"]) -> None:
    if len(summaries) == 0:
        print("No summaries found")
        return

    for summary in summaries:
        print("{} = {}".format(summary.key, summary.value))


@inherit_docstrings
class ListCommand(Command):
    """Command to list all recorded simulations.
    """
    _help = "list ingested manifests"

    def add_arguments(self, parser: argparse.ArgumentParser):
        parser.add_argument("--verbose", "-v", action="store_true", help="print more verbose output")

    class ListArgs(argparse.Namespace):
        verbose: bool

    def run(self, args: ListArgs, _: Config) -> None:
        from ..database.database import get_local_db

        db = get_local_db()
        simulations = db.list_simulations()
        _list_simulations(simulations, verbose=args.verbose)


@inherit_docstrings
class DeleteCommand(Command):
    """Command to delete simulation record.
    """
    _help = "delete an ingested manifest"

    def add_arguments(self, parser: argparse.ArgumentParser) -> None:
        parser.add_argument("sim_id", metavar="uuid|alias", help="simulation UUID or alias")

    class DeleteArgs(argparse.Namespace):
        sim_id: str

    def run(self, args: DeleteArgs, _: Config) -> None:
        from ..database.database import get_local_db

        db = get_local_db()
        db.delete_simulation(args.sim_id)

        print("success")


@inherit_docstrings
class InfoCommand(Command):
    """Command to print information about recorded simulation.
    """
    _help = "print information on ingested manifest"

    class InfoArgs(argparse.Namespace):
        sim_id: str

    def add_arguments(self, parser: argparse.ArgumentParser) -> None:
        parser.add_argument("sim_id", metavar="uuid|alias", help="simulation UUID or alias")

    def run(self, args: InfoArgs, _: Config) -> None:
        from ..database.database import get_local_db

        db = get_local_db()
        simulation = db.get_simulation(args.sim_id)
        if simulation is None:
            raise Exception("Failed to find simulation: " + args.sim_id)
        print(str(simulation))


@inherit_docstrings
class PushCommand(Command):
    """Command to push a recorded simulation to the remote simdb server.
    """
    _help = "push the simulation to the remote management system"

    class PushArgs(argparse.Namespace):
        sim_id: str

    def add_arguments(self, parser: argparse.ArgumentParser) -> None:
        parser.add_argument("sim_id", metavar="uuid|alias", help="simulation UUID or alias")

    def run(self, args: PushArgs, config: Config) -> None:
        from ..database.database import get_local_db
        from .remote_api import RemoteAPI

        api = RemoteAPI(config)
        db = get_local_db()
        simulation = db.get_simulation(args.sim_id)
        if simulation is None:
            raise Exception("Failed to find simulation: " + args.sim_id)
        api.push_simulation(simulation)

        print("success")


@inherit_docstrings
class ModifyCommand(Command):
    """Command to modify a recorded simulations.
    """
    _help = "modify the ingested simulation"

    class ModifyArgs(argparse.Namespace):
        sim_id: str
        alias: str

    def add_arguments(self, parser: argparse.ArgumentParser) -> None:
        parser.add_argument("sim_id", metavar="uuid|alias", help="simulation UUID or alias")
        parser.add_argument("--alias", help="new alias")

    def run(self, args: ModifyArgs, _: Config) -> None:
        from ..database.database import get_local_db

        if args.alias is not None:
            db = get_local_db()
            simulation = db.get_simulation(args.sim_id)
            simulation.alias = args.alias
            db.session.commit()
        else:
            print("nothing to do")


@inherit_docstrings
class ValidateCommand(Command):
    """Command to validate a recorded simulation.
    """
    _help = "validate the ingested simulation"

    class ValidateArgs(argparse.Namespace):
        sim_id: str

    def add_arguments(self, parser: argparse.ArgumentParser) -> None:
        parser.add_argument("sim_id", metavar="uuid|alias", help="simulation UUID or alias")

    def run(self, args: ValidateArgs, _: Config) -> None:
        from itertools import chain
        from ..database.database import get_local_db
        from ..validation import ValidationError
        from ..imas import validation as imas_validation
        from .manifest import DataObject

        db = get_local_db()
        simulation = db.get_simulation(args.sim_id)
        device = simulation.find_meta("device")
        scenario = simulation.find_meta("scenario")
        if not device:
            raise ValidationError("No device found in metadata")
        if len(device) > 1:
            raise ValidationError("Multiple devices found in metadata")
        if not scenario:
            raise ValidationError("No scenario found in metadata")
        if len(device) > 1:
            raise ValidationError("Multiple scenarios found in metadata")
        imas_names = set()
        for file in chain(simulation.inputs, simulation.outputs):
            if file.type == DataObject.Type.UDA:
                from ..uda.checksum import checksum as uda_checksum
                checksum = uda_checksum(file.file_name, file.directory)
            else:
                from ..checksum import sha1_checksum
                path = os.path.join(file.directory, file.file_name)
                checksum = sha1_checksum(path)
            if checksum != file.checksum:
                raise ValidationError("Checksum doest not match for file " + path)
            if file.type == DataObject.Type.IMAS:
                imas_names.add(file.file_name.split(".")[0])
        for name in imas_names:
            (tree, num) = name.split("_")
            shot = int(num[:-4])
            run = int(num[-4:])
            imas_obj = imas_validation.load_imas(shot, run)
            imas_validation.validate_imas(device[0].value, scenario[0].value, imas_obj)

        print("success")


@inherit_docstrings
class SimulationCommand(Command):
    """Command group for working with simulations including ingesting, querying and listing them.
    """
    _help = "manage ingested simulations"

    class NewCommand(Command):
        _help = "create a new blank simulation and return the UUID"

        def add_arguments(self, parser: argparse.ArgumentParser) -> None:
            parser.add_argument("--alias", "-a", help="alias of to assign to the simulation")
            parser.add_argument("--uuid-only", "-u", dest="uuid", default=False, action="store_true", help="return a new UUID but do not insert the new simulation into the database")

        class NewArgs(argparse.Namespace):
            alias: str

        def run(self, args: NewArgs, _: Config) -> None:
            from ..database.database import get_local_db
            from ..database.models import Simulation
            from .manifest import Manifest

            simulation = Simulation(Manifest())
            simulation.alias = args.alias
            if not args.uuid:
                db = get_local_db()
                db.insert_simulation(simulation)
            print(simulation.uuid)

    class AliasCommand(Command):
        _help = "generated a new unique alias"

        def add_arguments(self, parser: argparse.ArgumentParser) -> None:
            parser.add_argument("--prefix", "-p", help="prefix to use for the alias")

        class AliasArgs(argparse.Namespace):
            prefix: Optional[str]

        def run(self, args: AliasArgs, _: Config) -> None:
            from ..database.database import get_local_db

            prefix: str = args.prefix or 'sim'

            db = get_local_db()
            aliases = db.get_aliases(prefix)

            n = 1
            alias = prefix + ('%03d' % n)

            print(aliases)

            while alias in aliases:
                n += 1
                alias = prefix + ('%03d' % n)

            print(alias)

    _commands = {
        "push": PushCommand(),
        "modify": ModifyCommand(),
        "list": ListCommand(),
        "info": InfoCommand(),
        "delete": DeleteCommand(),
        "query": QueryCommand(),
        "ingest": IngestCommand(),
        "validate": ValidateCommand(),
        "new": NewCommand(),
        "alias": AliasCommand(),
    }

    def add_arguments(self, parser: argparse.ArgumentParser) -> None:
        command_parsers = parser.add_subparsers(title="action", dest="action")
        command_parsers.required = True

        for name, command in self._commands.items():
            sub_parser = command_parsers.add_parser(name, help=command.help)
            command.add_arguments(sub_parser)

    class SimulationArgs(PushCommand.PushArgs, ModifyCommand.ModifyArgs, ListCommand.ListArgs, DeleteCommand.DeleteArgs,
                         InfoCommand.InfoArgs, QueryCommand.QueryArgs):
        action: str

    def run(self, args: SimulationArgs, config: Config) -> None:
        self._commands[args.action].run(args, config)


@inherit_docstrings
class SummaryCommand(Command):
    """Command for processing summary IDSs and recording them against a simulation.
    """
    _help = "create and ingest IMAS summaries"

    class SummaryCreateCommand(Command):
        _help = "create the summary file"
        _script = "/work/imas/extra/bin/create_db_entry"

        def add_arguments(self, parser: argparse.ArgumentParser):
            parser.add_argument("file", help="file to create")
            parser.add_argument("shot", help="IDS shot")
            parser.add_argument("run", help="IDS run")

        def run(self, args: Any, _: Config) -> None:
            cmd = "{} --shot={} --run={}".format(self._script, args.shot, args.run)
            with os.popen(cmd) as p:
                with open(args.file) as f:
                    for line in p:
                        print(line, file=f, end="")

    class SummaryIngestCommand(Command):
        _help = "ingest the summary file"

        def add_arguments(self, parser: argparse.ArgumentParser):
            parser.add_argument("sim_id", metavar="uuid|alias", help="simulation UUID or alias")
            parser.add_argument("file", help="file to create")

        def run(self, args: Any, _: Config) -> None:
            from ..database.database import get_local_db
            import yaml

            with open(args.file) as f:
                y = yaml.load(f)
                summary = _flatten_dict(y)
            db = get_local_db()
            db.insert_summary(args.sim_id, summary)

    class SummaryListCommand(Command):
        _help = "list the ingested summaries"

        def add_arguments(self, parser: argparse.ArgumentParser):
            parser.add_argument("sim_id", metavar="uuid|alias", help="simulation UUID or alias")

        class SummaryListArgs(argparse.Namespace):
            sim_id: str

        def run(self, args: SummaryListArgs, _: Config) -> None:
            from ..database.database import get_local_db

            db = get_local_db()
            summaries = db.list_summaries(args.sim_id)
            _list_summaries(summaries)

    _commands = {
        "create": SummaryCreateCommand(),
        "ingest": SummaryIngestCommand(),
        "query": QueryCommand(QueryCommand.QueryType.SUMMARY),
        "list": SummaryListCommand(),
    }

    def add_arguments(self, parser: argparse.ArgumentParser):
        command_parsers = parser.add_subparsers(title="action", dest="sum_action")
        command_parsers.required = True

        for name, command in self._commands.items():
            sub_parser = command_parsers.add_parser(name, help=command.help)
            command.add_arguments(sub_parser)

    class SummaryArgs():
        sum_action: str

    def run(self, args: SummaryArgs, config: Config) -> None:
        self._commands[args.sum_action].run(args, config)


@inherit_docstrings
class RemoteCommand(Command):
    """Command for interacting with the remote simdb service.
    """
    _help = "query remote system"
    _parser: argparse.ArgumentParser

    @inherit_docstrings
    class RemoteDatabaseCommand(Command):
        """Command to manage the remote database [for development use only -- to be removed]."""
        _help = "manage remote simulation database file"

        def add_arguments(self, parser: argparse.ArgumentParser) -> None:
            parser.add_argument("remote_command", choices=["clear"],
                                help="clear all ingested simulations from the db")

        def run(self, args: argparse.Namespace, _: Config) -> None:
            pass

    @inherit_docstrings
    class RemoteSimulationCommand(Command):
        """Placeholder command to set up arguments for remote manipulations of simulations."""
        def __init__(self, help: str) -> None:
            self._help = help

        def add_arguments(self, parser: argparse.ArgumentParser) -> None:
            parser.add_argument("sim_id", metavar="uuid|alias", help="simulation UUID or alias")

        def run(self, args: Any, _: Config) -> None:
            pass

    def add_arguments(self, parser: argparse.ArgumentParser) -> None:
        command_parsers = parser.add_subparsers(title="action", dest="action")
        command_parsers.required = True

        parser.add_argument("-v", "--verbose", action="store_true", help="print more verbose output")

        commands = {
            "list": ListCommand(),
            "info": InfoCommand(),
            "query": QueryCommand(),
            "publish": RemoteCommand.RemoteSimulationCommand("publish staged simulation"),
            "delete": RemoteCommand.RemoteSimulationCommand("delete staged simulation"),
            "database": RemoteCommand.RemoteDatabaseCommand(),
        }

        for name, command in commands.items():
            sub_parser = command_parsers.add_parser(name, help=command.help)
            command.add_arguments(sub_parser)

    class RemoteArgs(argparse.Namespace):
        action: str
        verbose: bool
        sim_id: str

    def run(self, args: RemoteArgs, config: Config) -> None:
        from .remote_api import RemoteAPI

        api = RemoteAPI(config)
        if args.action == "list":
            simulations = api.list_simulations()
            _list_simulations(simulations, verbose=args.verbose)
        elif args.action == "info":
            simulation = api.get_simulation(args.sim_id)
            print(str(simulation))
        elif args.action == "database":
            api.reset_database()
            print("success")
        elif args.action == "publish":
            api.publish_simulation(args.sim_id)
            print("success")
        elif args.action == "delete":
            result = api.delete_simulation(args.sim_id)
            print("deleted simulation: " + result["deleted"]["simulation"])
            if result["deleted"]["files"]:
                for file in result["deleted"]["files"]:
                    print("              file: " + file)
        elif args.action == "query":
            simulations = api.query_simulations(args.constraint)
            _list_simulations(simulations, verbose=args.verbose, metadata_names=args.attributes)


@inherit_docstrings
class ManifestCommand(Command):
    """Command for working with manifest files.
    """
    _help = "create/check manifest file"

    def add_arguments(self, parser: argparse.ArgumentParser) -> None:
        parser.add_argument("action", choices=["check", "create"])
        parser.add_argument("manifest_file", help="manifest file location")

    class ManifestArgs(argparse.Namespace):
        action: str
        manifest_file: str

    def run(self, args: ManifestArgs, _: Config) -> None:
        from .manifest import (Manifest, InvalidManifest)

        manifest = Manifest()

        if args.action == "check":
            manifest.load(args.manifest_file)
            try:
                manifest.validate()
                print("ok")
            except InvalidManifest as err:
                print(err)
                return
        elif args.action == "create":
            Manifest.from_template().save(args.manifest_file)


@inherit_docstrings
class DatabaseCommand(Command):
    """Command for manipulating user's local database.
    """
    _help = "manage local simulation database file"

    class ClearCommand(Command):
        _help = "clear the database"

        def add_arguments(self, parser: argparse.ArgumentParser) -> None:
            pass

        def run(self, args: Any, _: Config) -> None:
            from ..database.database import get_local_db

            db = get_local_db()
            db.reset()

    class ControlledVocabularyCommand(Command):
        _help = "manage controlled vocabulary"

        def add_arguments(self, parser: argparse.ArgumentParser) -> None:
            parser.add_argument("cv_action", choices=["new", "update", "clear", "list", "print", "delete"],
                                help="action to perform")
            parser.add_argument("name", help="vocabulary name", nargs="?")
            parser.add_argument("words", nargs="*", help="vocabulary words")

        def run(self, args: Any, _: Config) -> None:
            from ..database.database import get_local_db

            db = get_local_db()
            if args.cv_action == "new":
                _required_argument(args, "new", "name")
                _required_argument(args, "new", "words")
                db.new_vocabulary(args.name, args.words)
            elif args.cv_action == "update":
                _required_argument(args, "update", "name")
                _required_argument(args, "update", "words")
                db.clear_vocabulary_words(args.name, args.words)
            elif args.cv_action == "clear":
                _required_argument(args, "clear", "name")
                db.clear_vocabulary(args.name)
            elif args.cv_action == "delete":
                _required_argument(args, "delete", "name")
                db.delete_vocabulary(args.name)
            elif args.cv_action == "list":
                vocabs = db.get_vocabularies()
                for vocab in vocabs:
                    print("{} - {} words".format(vocab.name, len(vocab.words)))
            elif args.cv_action == "print":
                _required_argument(args, "print", "name")
                vocab = db.get_vocabulary(args.name)
                print(vocab.name + ':')
                for word in vocab.words:
                    print('  ' + word.value)
            else:
                raise Exception("Unknown action " + args.cv_action)

    class ReferenceCommand(Command):
        _help = "manage reference scenarios"

        def add_arguments(self, parser: argparse.ArgumentParser) -> None:
            parser.add_argument("ref_action", choices=["load", "list", "print", "delete"],
                                help="action to perform")
            parser.add_argument("--shot", help="IDS shot number", type=int)
            parser.add_argument("--run", help="IDS run number", type=int)
            parser.add_argument("--device", help="device name")
            parser.add_argument("--scenario", help="scenario name")
            parser.add_argument("--path", help="ids path")
            parser.add_argument("--ids", help="names of the IDSs to use", action="append")

        def run(self, args: Any, _: Config) -> None:
            from ..database.database import get_local_db
            from ..imas import validation as imas_validation
            from ..validation import TestParameters

            db = get_local_db()
            if args.ref_action == "load":
                _required_argument(args, "load", "shot")
                _required_argument(args, "load", "run")
                _required_argument(args, "load", "device")
                _required_argument(args, "load", "scenario")
                _required_argument(args, "load", "ids")
                imas_obj = imas_validation.load_imas(args.shot, args.run)
                imas_validation.save_validation_parameters(args.device, args.scenario, imas_obj, args.ids)
            elif args.ref_action == "delete":
                pass
            elif args.ref_action == "list":
                params = db.list_validation_parameters(None, None)
                _list_validation_parameters(params)
            elif args.ref_action == "print":
                _required_argument(args, "print", "device")
                _required_argument(args, "print", "scenario")
                params = db.list_validation_parameters(args.device, args.scenario)
                print("Device: {}\nScenario: {}\nPaths:".format(args.device, args.scenario))
                for param in params:
                    print("{} {}".format(param.path, str(TestParameters.from_db_parameters(param))))
            else:
                raise Exception("Unknown action " + args.cv_action)

    _commands = {
        "clear": ClearCommand(),
        "cv": ControlledVocabularyCommand(),
        "reference": ReferenceCommand(),
    }

    def add_arguments(self, parser: argparse.ArgumentParser) -> None:
        command_parsers = parser.add_subparsers(title="action", dest="action")
        command_parsers.required = True

        for name, command in self._commands.items():
            sub_parser = command_parsers.add_parser(name, help=command.help)
            command.add_arguments(sub_parser)

    def run(self, args: argparse.Namespace, config: Config) -> None:
        self._commands[args.action].run(args, config)


@inherit_docstrings
class ConfigCommand(Command):
    """Command for querying/editing the user's application configuration"""
    _help = "query/update application configuration"

    class Actions(Enum):
        GET = auto()
        SET = auto()
        LIST = auto()

        def __str__(self) -> str:
            return self.name.lower()

        @staticmethod
        def from_string(s: str) -> 'ConfigCommand.Actions':
            try:
                return ConfigCommand.Actions[s.upper()]
            except KeyError:
                raise ValueError()

    def add_arguments(self, parser: argparse.ArgumentParser) -> None:
        parser.add_argument("action", type=ConfigCommand.Actions.from_string, choices=list(ConfigCommand.Actions),
                            help="action to perform")
        parser.add_argument("option", help="configuration option", nargs='?')
        parser.add_argument("value", help="value to set the option to (only for set action)", nargs='?')

    class ConfigArgs(argparse.Namespace):
        action: str
        option: str
        value: str

    def run(self, args: ConfigArgs, config: Config) -> None:
        if args.action == ConfigCommand.Actions.GET:
            _required_argument(args, "set", "option")
            print(config.get_option(args.option))
        elif args.action == ConfigCommand.Actions.SET:
            _required_argument(args, "set", "option")
            _required_argument(args, "set", "value")
            config.set_option(args.option, args.value)
        elif args.action == ConfigCommand.Actions.LIST:
            for i in config.list_options():
                print(i)


@inherit_docstrings
class AliasCommand(Command):
    """Command for querying used aliases"""
    _help = "query remote and local aliases"

    class Actions(Enum):
        SEARCH = auto()
        LIST = auto()

        def __str__(self) -> str:
            return self.name.lower()

        @staticmethod
        def from_string(s: str) -> 'AliasCommand.Actions':
            try:
                return AliasCommand.Actions[s.upper()]
            except KeyError:
                raise ValueError()

    def add_arguments(self, parser: argparse.ArgumentParser) -> None:
        parser.add_argument("--action", type=AliasCommand.Actions.from_string, choices=list(AliasCommand.Actions),
                            help="action to perform", dest="alias_action")
        parser.add_argument("value", help="search value (only for search action)", nargs='?')

    class AliasArgs(argparse.Namespace):
        alias_action: str
        value: str

    @staticmethod
    def _search_aliases(config: Config, value: str):
        from .remote_api import RemoteAPI
        from ..database.database import get_local_db

        api = RemoteAPI(config)
        simulations = api.list_simulations()

        db = get_local_db()
        simulations += db.list_simulations()

        aliases = [sim.alias for sim in simulations if sim.alias.contains(value)]
        for alias in aliases:
            print(alias)

    @staticmethod
    def _list_aliases(config: Config):
        from .remote_api import RemoteAPI
        from ..database.database import get_local_db

        api = RemoteAPI(config)
        remote_simulations = api.list_simulations()

        db = get_local_db()
        local_simulations = db.list_simulations()

        print("Remote:")
        for sim in remote_simulations:
            print(" ", sim.alias)

        print("Local:")
        for sim in local_simulations:
            print(" ", sim.alias)

    def run(self, args: AliasArgs, config: Config) -> None:
        if args.alias_action == AliasCommand.Actions.SEARCH:
            _required_argument(args, "search", "value")
            AliasCommand._search_aliases(config, args.value)
        elif args.alias_action == AliasCommand.Actions.LIST:
            AliasCommand._list_aliases(config)
